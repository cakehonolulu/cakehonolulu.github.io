<!doctype html>
<html class="not-ready lg:text-base" lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />

  <!-- Title -->
  <title>
    How Emulators Work? - cakehonolulu&#x27;s blog
  </title>

  <!-- Meta -->
  <meta name="theme-color" />

  
  <!-- Author -->
  
  <!---->
  
  <!---->
  
  <!---->
  
  <!---->
  
  <!---->
  <meta name="description" content="A 10 minute read detailing how most emulators work nowadays" />
  <meta name="author" content="cakehonolulu" />
  <!-- The Open Graph protocol -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="How Emulators Work?" />
  <meta property="og:site_name" content="cakehonolulu&#x27;s blog" />
  <meta property="og:description" content="A 10 minute read detailing how most emulators work nowadays" />
  <meta property="og:url" content="https:&#x2F;&#x2F;cakehonolulu.github.io&#x2F;how-emulators-work&#x2F;" />
  
  <!---->
  
  <!---->
  

  <!-- CSS & JS -->
  <link rel="preload stylesheet" as="style" href="https://cakehonolulu.github.io/main.css" />
  <style>
    :root {
      --bg: #f4f4f5;
      --bg-dark: #18181b;
      --header: #e4e4e7;
      --header-dark: #27272a;
    }
  </style>

  

  <!-- Dark Icon -->
  <link rel="preload" as="image" href="https://cakehonolulu.github.io/icons/theme.svg" />

  <!-- Math -->
  
  <!---->
  <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.css"
  crossorigin="anonymous"
/>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16/dist/katex.min.js"
  crossorigin="anonymous"
></script>
<script
  defer
  src="https://cdn.jsdelivr.net/npm/katex@0.16/dist/contrib/auto-render.min.js"
  crossorigin="anonymous"
></script>

<script>
  document.addEventListener("DOMContentLoaded", () =>
    renderMathInElement(document.body, {
      // customised options
      // • auto-render specific keys, e.g.:
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
      ],
      // • rendering keys, e.g.:
      throwOnError: false,
    }),
  );
</script>

  <!---->
  
  <!---->

  <!-- Mermaid -->
  
  <!---->
  <script type="module">
  import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs";

  const initMermaid = (isDark) => {
    mermaid.initialize({
      theme: isDark ? "dark" : "default",
      startOnLoad: false,
    });
    mermaid.run();
  };

  // Add data-mermaid-code attribute on all mermaid block.
  document.querySelectorAll(".mermaid").forEach((element) => {
    element.setAttribute("data-mermaid-code", element.innerHTML);
  });

  // Re-render mermaid when theme changed.
  document.body.addEventListener("set-theme", (e) => {
    document.querySelectorAll(".mermaid").forEach((element) => {
      const mermaidCode = element.getAttribute("data-mermaid-code");
      if (mermaidCode != null) {
        element.removeAttribute("data-processed");
        element.innerHTML = mermaidCode;
      }
    });
    initMermaid(e.detail === "dark");
  });

  // The es module script will load defer, so the localStorage should already be set by script in header.
  // If this script is loaded first, the script in header will dispatch an event to re-render mermaid, it's works too.
  initMermaid(localStorage.getItem("dark") === "true");
</script>

  <!---->
  
  <!---->

  <!-- Favicon -->
  <link rel="icon" href="https://cakehonolulu.github.io/favicon.ico" />
  <link rel="apple-touch-icon" href="https://cakehonolulu.github.io/apple-touch-icon.png" />

  <!-- Feeds -->
  
  <!---->
  
  <link
    rel="alternate"
    type="application/atom+xml"
    title="Atom"
    href="https://cakehonolulu.github.io/atom.xml"
  />
   
  <link
    rel="alternate"
    type="application/rss+xml"
    title="RSS"
    href="https://cakehonolulu.github.io/rss.xml"
  />
  
  <!---->
  

  <!-- Canonical -->
  <link rel="canonical" href="https:&#x2F;&#x2F;cakehonolulu.github.io&#x2F;how-emulators-work&#x2F;" />

  <!-- Head inject -->
  
</head>

  <body class="text-black duration-200 ease-out dark:text-white">
    <header
  class="header fixed top-0 z-40 mx-auto min-h-[3.5rem] w-full"
>
  <div class="mx-auto w-full max-w-4xl p-3 lg:flex lg:justify-between">
    <div class="flex justify-between">
      <div class="flex items-center">
        <a class="text-2xl font-semibold" href="https://cakehonolulu.github.io">cakehonolulu&#x27;s blog</a>
        <div
          class="btn-dark ml-4 h-6 w-6 shrink-0 cursor-pointer text-[0] [background:url(./icons/theme.svg)_left_center/cover_no-repeat] dark:invert dark:[background-position:right]"
          role="button"
          aria-label="Dark"
        ></div>
      </div>
      
      <div
        class="btn-menu relative z-50 flex h-8 w-8 shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden"
        role="button"
        aria-label="Menu"
      ></div>
      
    </div>
    <script>
      // base
      const htmlClass = document.documentElement.classList;
      setTimeout(() => {
        htmlClass.remove("not-ready");
      }, 10);

      // mobile menu
      const btnMenu = document.querySelector(".btn-menu");
      btnMenu?.addEventListener("click", () => {
        htmlClass.toggle("open");
      });

      // dark theme
      const setDark = (isDark) => {
        if (isDark) {
          document.body.dispatchEvent(new CustomEvent("set-theme", { detail: "dark" }));
          htmlClass.add("dark");
        } else {
          document.body.dispatchEvent(new CustomEvent("set-theme", { detail: "light" }));
          htmlClass.remove("dark");
        }
        localStorage.setItem("dark", isDark);
      };

      // init
      const darkScheme = window.matchMedia("(prefers-color-scheme: dark)");
      if (htmlClass.contains("dark")) {
        setDark(true);
      } else {
        const darkVal = localStorage.getItem("dark");
        setDark(darkVal ? darkVal === "true" : darkScheme.matches);
      }

      // listen system
      darkScheme.addEventListener("change", (event) => {
        setDark(event.matches);
      });

      // manual switch
      const btnDark = document.querySelector(".btn-dark");
      btnDark.addEventListener("click", () => {
        setDark(localStorage.getItem("dark") !== "true");
      });
    </script>
    
    <nav class="flex w-full items-center lg:w-auto">
      <ul
        class="nav-wrapper flex w-full flex-col py-2 lg:w-auto lg:flex-row lg:self-center lg:py-0"
      >
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/about"
            >About</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/projects"
            >Projects</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/blog"
            >Blog</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/archive"
            >Archive</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/tags"
            >Tags</a
          >
        </li>
        
        <li>
          <a
            class="primary-link block py-2 text-center text-lg font-medium lg:px-3 lg:py-0"
            href="https://cakehonolulu.github.io/docs"
            >Docs</a
          >
        </li>
        
      </ul>
      <!-- Header Nav inject -->
      
    </nav>
    
  </div>
</header>


    <!-- Body Start inject -->
    

    <main
      class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl break-words px-4 pb-16 pt-32 dark:prose-invert prose-pre:rounded-lg prose-img:rounded-lg"
    >
      
<article>
  <!-- Page Start inject -->
  

  <header class="mb-16">
    <h1 class="!my-0 pb-2.5">How Emulators Work?</h1>
    <div class="text-sm antialiased opacity-60">
  
  <time>2024-01-09</time>
  <span class="mx-1">&middot;</span>
  <span>11min</span>
  <!---->
  <!---->
  <!---->
  <!---->
  
  <span class="mx-1">&middot;</span>
  <span>cakehonolulu</span>
  
  <!-- Page Info inject -->
  
</div>

  </header>

  

  <!-- TOC -->
  <!---->
<div class="block-bg mb-12 flex rounded-lg p-2 text-lg">
  <details>
    <summary class="cursor-pointer py-1 pl-4">
      <span>Table of Contents</span>
    </summary>
    <div class="px-2">
      <ul>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#what-is-an-emulator"
            >What is an emulator?</a
          >
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#types-of-emulation"
            >Types of emulation</a
          >
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#hle-vs-lle"
            >HLE vs LLE</a
          >
          
          <ul>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#lle"
                >LLE</a
              >
            </li>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#hle"
                >HLE</a
              >
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#defining-the-target"
            >Defining the target</a
          >
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#emulation-loop"
            >Emulation loop</a
          >
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#cpu-emulation-techniques"
            >CPU emulation techniques</a
          >
          
          <ul>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#interpreter"
                >Interpreter</a
              >
            </li>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#cached-interpreter"
                >Cached Interpreter</a
              >
            </li>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#dynamic-recompiler"
                >Dynamic Recompiler</a
              >
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#peripherals"
            >Peripherals</a
          >
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#bonus-track"
            >Bonus Track</a
          >
          
          <ul>
            
            <li>
              <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#aot"
                >AoT</a
              >
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="no-underline hover:underline" href="https://cakehonolulu.github.io/how-emulators-work/#credits"
            >Credits</a
          >
          
        </li>
        
      </ul>
    </div>
  </details>
</div>

<!---->

  <!-- Content -->
  <section><p>I, as many more, grew up playing retro videogames on emulators (And the original hardware!): from sprite-based machines, to more complex, 3D-capable monsters.</p>
<div style="text-align: center;">
<p><img src="https://i.blogs.es/juegos/9648/metal_slug_2/fotos/noticias/metal_slug_2-5218501.jpg" alt="Metal Slug" />
<em>Metal Slug, an impressive 2D game; developed for SNK's Neo-Geo</em></p>
</div>
<p>A few years ago, I started to ask myself how an emulator works; I initially believed it <em>had</em> to be some sort of magic, but at the end of the day, code is just that, <em>code</em> (<em>Technically</em>, you <em>can</em> develop an emulator from an ECE-perspective; look up <a href="https://en.wikipedia.org/wiki/Verilog">Verilog</a> or really, any <a href="https://en.wikipedia.org/wiki/Hardware_description_language">Hardware-Description-Language</a>, but that's beyond the scope for this post).</p>
<h1 id="what-is-an-emulator">What is an emulator?</h1>
<p>Let's start by defining what an emulator (Not to be confused with simulator) really is.</p>
<p>According to <a href="https://en.wikipedia.org/wiki/Emulator">Wikipedia</a>:</p>
<pre data-lang="html" style="background-color:#2b303b;color:#c0c5ce;" class="language-html "><code class="language-html" data-lang="html"><span>In computing, an emulator is hardware or software that
</span><span>enables one computer  system (called the host) to behave
</span><span>like another computer system (called the guest).
</span><span>
</span><span>An emulator typically enables the host system to run software or 
</span><span>use peripheral devices designed for the guest system.
</span><span>Emulation refers to the ability of a computer program in
</span><span>an electronic device to emulate (or imitate) another program or device. 
</span></code></pre>
<p>The key takeaway here, is the <em>ability</em> to run code that is designed for one system on another one.</p>
<p>Examples of this could be, running aarch64 code on your shiny new Intel/AMD PC (Playing a videogame designed for Android, for example); the technique Apple employs for their newer M-line of processors (Which are 64-bit ARM chips) but they are able to maintain backwards compatibility to a degree with macOS software designed for their older Intel machines (And doing so in a fast and efficient manner, using <a href="https://en.wikipedia.org/wiki/Rosetta_(software)#Rosetta_2">Rosetta 2</a>)...</p>
<p>But how can <em>we</em>, as individuals, tackle this problem?</p>
<p>Well, there's lots of ways of doing so.</p>
<h1 id="types-of-emulation">Types of emulation</h1>
<p>The following paragraph contains information about a type of emulators that have lately emerged; they're more state-of-the-art in comparison with good-old already-existing emulators, it's meant to illustrate, it can be confusing for newbies so you can skip to the <a href="https://cakehonolulu.github.io/how-emulators-work/#hle-vs-lle">HLE vs LLE</a> chapter if you want.</p>
<hr />
<p>A brief paragraph: As of recent times, a new way to experience retro systems has appeared, not to confuse you, but I'll give a brief explanation as to what FPGA-based emulation is and not.</p>
<p><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array">FPGAs</a> are integrated circuits whose behaviour can be repgrogrammed at the logic level after manufacturing, they can be programmed using HDL's (Hardware description languages) which goes through a series of steps before getting executed by the development board.</p>
<div style="text-align: center;">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a1/Xerox_ColorQube_8570_-_Main_controller_-_Xilinx_Spartan_XC3S400A-0205.jpg/220px-Xerox_ColorQube_8570_-_Main_controller_-_Xilinx_Spartan_XC3S400A-0205.jpg" alt="Spartan FPGA" /></p>
<p><em>The Xilinx Spartan FPGA</em></p>
</div>
<p>What this basically means is, that you can effectively replicate any existing chip on an FPGA.</p>
<p>In comparison with traditional emulators (Which, run on top of an operating system), FPGA-based emulators have a bunch of neat advantages due do the nature of the technology itself.</p>
<p>For example, operating systems tend not to give you a fine-grained scheduling; let's say your emulator wants to handle keypad inputs; you need to somehow interact with the underlying OS to perform such task, but the OS itself can then assign the priority it sees fitting so the latency (Normally in miliseconds) can fluctuate making accurate emulation really difficult. Worth mentioning, that normally, the more accurate it needs to be, the more power-hungry the emulator will end up.</p>
<p>FPGAs benefit from the parallelism they can archieve due to their nature, and also can maintain the components clocked much more accurately again, due to their nature; doing so while not requiring as much power as a normal, PC emulator.</p>
<p>Anyhow, back to the main topic.</p>
<h1 id="hle-vs-lle">HLE vs LLE</h1>
<p>There's two ways to understand emulation; and this varies by the level of closeness to the hardware you decide to entangle yourself with.</p>
<h2 id="lle">LLE</h2>
<p>LLE stands for Low-level Emulation. What this means is, closely replicating the target hardware at the bare-metal level.</p>
<p>You must emulate every bit of the system to make it work; that means implementing a CPU core that can execute the foreign instructions; providing an interface for it to send/recieve data to/from peripherals and respecting the timings of all the components to make it as accurate as possible (You can read further on this topic if you look up <a href="https://retrocomputing.stackexchange.com/a/1195">Cycle Accuracy</a>).</p>
<h2 id="hle">HLE</h2>
<p>HLE on the other hand, can be understood as a MITM between the target library calls and mapping them to host-compatible ones; let's say we have <em>System A</em> which, somewhere on it's code, does this:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// System A function responsible of init-ing the FB
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">libGfxInitFramebuffer</span><span>()
</span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">libGfxSetupFramebuffer</span><span>())
</span><span>        </span><span style="color:#b48ead;">goto</span><span> fail;
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">libGfxClearFramebuffer</span><span>())
</span><span>        </span><span style="color:#b48ead;">goto</span><span> fail;
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>fail:
</span><span>    </span><span style="color:#bf616a;">libDebugPrint</span><span>(&quot;</span><span style="color:#a3be8c;">Failed to initialize the framebuffer!</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span></code></pre>
<p>If we're trying to HLE System A, we need to figure out a way to first, detect that this function is being called (Normally, there's a piece of code responsible for intercepting, for example, syscalls) and instead of executing the target code, executing a function written for the host architecture that archieves the same but without relying on the target-specific hardware details.</p>
<p>We could for example, intercept it and call the following code in a PC:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// Host system function responsible of init-ing the FB
</span><span style="color:#65737e;">// Assuming we&#39;re using SDL and renderer is a SDL_Renderer
</span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">libGfxInitFramebuffer</span><span>()
</span><span>{
</span><span>    </span><span style="color:#bf616a;">SDL_SetRenderDrawColor</span><span>(renderer, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">255</span><span>);
</span><span>    </span><span style="color:#bf616a;">SDL_RenderClear</span><span>(renderer);
</span><span>    </span><span style="color:#bf616a;">SDL_RenderPresent</span><span>(renderer);
</span><span>
</span><span>    </span><span style="color:#65737e;">// We do not handle error-checking for simplicity&#39;s sake
</span><span>}
</span></code></pre>
<p>And that's the basic principle behind HLE. You also need a way to intercept those library calls; for example, let's say we're interpreting target (System A) CPU instructions, and suddenly, we encounter a <code>syscall</code> instruction.</p>
<p>Let's assume this <code>syscall</code> instruction in System A works by specifying the <code>syscall</code> type on register <code>A</code> and the required arguments on registers <code>B</code> and <code>C</code>.</p>
<p>Imagine we find this:</p>
<pre data-lang="asm" style="background-color:#2b303b;color:#c0c5ce;" class="language-asm "><code class="language-asm" data-lang="asm"><span style="color:#8fa1b3;">move </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#96b5b4;">$</span><span style="color:#8fa1b3;">A
</span><span style="color:#b48ead;">syscall
</span></code></pre>
<p>This basically would call syscall number 3 on the syscall table, which, for example, could be our previously explained <code>libGfxInitFramebuffer()</code>.</p>
<p>You'd then need to detect this behaviour whilst executing the target code, intercept it and redirect execution and adjust the emulation state accordingly (Maybe adjusting cycle count to account for the original length of the syscall function... etc).</p>
<p>It's also important to note, that nowadays (Moreso with more recent consoles), there's a trend to mix both LLE and HLE techniques to get thehe benefits of both approaches. There's some components that you can HLE to reduce the processing hurdle of more complex subsystems a machine can have.</p>
<h1 id="defining-the-target">Defining the target</h1>
<p>Now that we finally have laid down the concepts related to emulation; let's find a target that has a CPU that has a relatively easy implementation in software.</p>
<p>We'll focus for example on the Amstrad GX4000. A 3rd generation, PAL home console that was launched in the 80s.</p>
<div style="text-align: center;">
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Amstrad-GX4000-Console-Set.png/1280px-Amstrad-GX4000-Console-Set.png" alt="Amstrad GX000" />
<em>The Amstrad GX4000</em></p>
</div>
<p>The specs are very straightforward; an 8-bit Zilog Z80A at 4 MHz a custom chip that handled sprites, Sound DMAs and Interrupts.</p>
<p>Sound-wise; a 3-channel stereo, AY-3-8912 chip.</p>
<p>As for space, 64 KiB of RAM, 16 KiB of Video RAM and 32 KiB of ROM.</p>
<p>Really simple.</p>
<p>We'll focus on CPU emulation and we'll ignore the rest of the peripherals for now.</p>
<h1 id="emulation-loop">Emulation loop</h1>
<p>Once you find the detailed specs for the machine you want to target; it's time to work.</p>
<p>The usual recommendation is to find on the Internet as much documentation as you can; but depending on the target, you may find less stuff; so be prepared to reverse-engineer if needed.</p>
<p>For the major players in the market, there's popular resources online that give a very detailed explanation of the entire system; but again, your mileage may vary.</p>
<p>The basics for emulating a CPU are, knowing how a CPU works, here's a pretty simple diagram:</p>
<div style="text-align: center;">
<p><img src="https://i.pinimg.com/originals/d7/f0/29/d7f0297a06f5f6e36f8cbd50a77a1fc9.png" alt="FDE Cycle" />
<em>The fetch-decode-execute cycle</em></p>
</div>
<p>Basically, we need to fetch data from the memory, decode it and execute it; profit.</p>
<div style="text-align: center;">
<p><img src="https://i.kym-cdn.com/photos/images/newsfeed/000/572/078/d6d.jpg" alt="Owl" /></p>
<p><em>2 simple steps!</em></p>
</div>
<p>In all seriousness; it's really that <em>simple</em>¹</p>
<p style="font-size: 0.7rem"> ¹.- Depending on the CPU, it may be less simple (Think of possible address modes, the straightforward-ness of the opcode decoding, the pipeline it may have, the timings...) </p>
<p>Let's get down</p>
<h1 id="cpu-emulation-techniques">CPU emulation techniques</h1>
<h2 id="interpreter">Interpreter</h2>
<p>We'll start with the more easier type of technique; an Interpreter.</p>
<p>Let's have some pseudocode explain the rest, we'll do some assumptions that don't map to the real Z80A, to simplify the explanation and the code (We assume opcode size == 1 byte, no addressing modes, no banked register set...):</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#65737e;">// Ignoring the boilerplate code, such as headers, irrelevant functions and such
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Bus {
</span><span>    byte ram[</span><span style="color:#d08770;">64</span><span> KiB];
</span><span>    ....
</span><span>}
</span><span>
</span><span style="color:#b48ead;">struct </span><span>Cpu {
</span><span>    byte A, B, C, D, E, H, L; </span><span style="color:#65737e;">// General-Prupose Registers
</span><span>    byte F; </span><span style="color:#65737e;">// Special Flags Register
</span><span>    byte IX, IY; </span><span style="color:#65737e;">// Index Registers
</span><span>    byte SP; </span><span style="color:#65737e;">// Stack Pointer Register
</span><span>    byte PC; </span><span style="color:#65737e;">// Program Counter Register
</span><span>    ...
</span><span>}
</span><span>
</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">    Bus and Cpu are initialized by main() or another function,
</span><span style="color:#65737e;">    the ram array has the target binary already loaded at a
</span><span style="color:#65737e;">    specific offset and the PC (Which effectively acts as a
</span><span style="color:#65737e;">    pointer to memory) is set to that memory offset.
</span><span style="color:#65737e;">
</span><span style="color:#65737e;">    That way once we read from ram we can just do ram[cpu-&gt;PC]
</span><span style="color:#65737e;">    to get the opcode.
</span><span style="color:#65737e;">*/
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">cpu_fde</span><span>(Bus *</span><span style="color:#bf616a;">bus</span><span>, Cpu *</span><span style="color:#bf616a;">cpu</span><span>)
</span><span>{
</span><span>    </span><span style="color:#65737e;">// Get the cpu instruction from memory pointed by the PC register
</span><span>    byte opcode = bus-&gt;ram[cpu-&gt;PC];
</span><span>
</span><span>    </span><span style="color:#b48ead;">switch</span><span>(opcode)
</span><span>    {
</span><span>        </span><span style="color:#65737e;">// ADD A, B Instruction
</span><span>        </span><span style="color:#b48ead;">case </span><span style="color:#d08770;">0x00</span><span>:
</span><span>            </span><span style="color:#65737e;">// Add B to A
</span><span>            cpu-&gt;A += cpu-&gt;B;
</span><span>            </span><span style="color:#65737e;">// Increment PC
</span><span>            cpu-&gt;PC++;
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">case </span><span>...:
</span><span>            ...
</span><span>
</span><span>        ...
</span><span>
</span><span>        </span><span style="color:#b48ead;">default</span><span>:
</span><span>            </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">Opcode unimplemented! 0x</span><span style="color:#d08770;">%02X</span><span style="color:#96b5b4;">\n</span><span>&quot;, opcode);
</span><span>            </span><span style="color:#96b5b4;">exit</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>    }
</span><span>
</span><span>}
</span><span>
</span></code></pre>
<p>This is the skeleton for an emulator; think of the PC (Program Counter, sometimes also called IP, Instruction Pointer) register as a pointer to memory from where we'll read instructions from.</p>
<p>Normally, the PC then will get incremented by 1 at the end of the opcode processing (But some opcodes that handle PC relocation, such as JUMPs or CALLs may add an offset to it or straight up setting it to a determinate value).</p>
<p>In reality, PC will increment <code>sizeof(opcode)</code>, but there may be some exceptions to that in some architectures; be always mindful when designing the main loop.</p>
<p>And that's it, you've just designed a primitive interpreter loop.</p>
<p>This is one of the many ways to implement the fetch-decode-execute loop; and one of the slowest ones too; think the amount of instructions per second you need to decode and execute in 8MHz's worth of time.</p>
<p>It adds up.</p>
<h2 id="cached-interpreter">Cached Interpreter</h2>
<p>So far we've covered the basis for an Interpreter; but there's other techniques to gain an advantage, speed-wise.</p>
<p>For instance, you could cache the instructions you're translating in blocks so that it alleviates the fetch-decode hotspot a bit; as it'd only need to process it once (Ignoring that code can be self-modifying and in that case you'd need to invalidate and recompile the affected block; but that's for another day).</p>
<h2 id="dynamic-recompiler">Dynamic Recompiler</h2>
<p>By far, one of the most efficient ways to tackle emulation is by developing a Dynamic Recompiler (Just-in-Time compiler); which interprets the target, arch-uncompatible instructions; and translates them to host instructions. For example, <a href="https://en.wikipedia.org/wiki/Rosetta_(software)#Rosetta_2">Rosetta 2</a> converts x86_64 instructions to aarch64 ones and runs them in a efficient and fast manner.</p>
<p>It's one of the most complex ones, but also, one of the most rewarding ones; there's several challenges to tackle when developing a Dynamic Recompiler; such as deciding how to to the actual recompilation:</p>
<p>Do we want an emitter that directly translates the instructions? Maybe we want instead to use some sort of IL (Intermediate language) so that a compiler backend (Think, LLVM) can introduce code optimizations and do the translation? How do we handle self-modifying code? And what about register spilling (Imagine targetting an arch that has more registers than your host one, you may need to use some stack trickery or another technique to decide the least used registers and swap them into the host ones as needed)?</p>
<p>As you can see, there are many more challenges when trying to go the Dynamic Recompilation route; but it's a really interesting path to go down.</p>
<div style="text-align: center;">
<p><img src="https://static.wixstatic.com/media/0ca71f_1a3d7cffee16433db44fb5155c7e225a.png/v1/fill/w_1132,h_818,al_c,q_90,usm_0.66_1.00_0.01,enc_auto/0ca71f_1a3d7cffee16433db44fb5155c7e225a.png" alt="JIT" /></p>
<p><em>A simple JIT diagram, it also needs a cache for the compiled blocks</em></p>
</div>
<h1 id="peripherals">Peripherals</h1>
<p>There's also the added challenge of handling peripherals; there's cases where you'll find I/O operations CPU-wise that interact with the peripherals on the system; or some other times, they can be memory-mapped.</p>
<p>In any case, there's some food for thought involved into deciding the best way to tackle both of the systems.</p>
<p>A simple, pseudocode example that explains the memory-mapped approach:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span>
</span><span style="color:#65737e;">/*
</span><span style="color:#65737e;">    This can be called with opcodes like LOAD ($A), $0x20
</span><span style="color:#65737e;">    (Loads 0x20 to the address pointed by A)
</span><span style="color:#65737e;">*/
</span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">memory_write_byte</span><span>(Bus *</span><span style="color:#bf616a;">bus</span><span>, Cpu *</span><span style="color:#bf616a;">cpu</span><span>, </span><span style="color:#b48ead;">long </span><span style="color:#bf616a;">address</span><span>, byte </span><span style="color:#bf616a;">value</span><span>)
</span><span>{
</span><span>    </span><span style="color:#b48ead;">switch </span><span>(address)
</span><span>    {
</span><span>        </span><span style="color:#65737e;">// Main RAM
</span><span>        </span><span style="color:#b48ead;">case </span><span style="color:#d08770;">0x0 </span><span>... </span><span style="color:#d08770;">0x1000</span><span>:
</span><span>            bus-&gt;ram[address] = value;
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>        cd 
</span><span>        </span><span style="color:#65737e;">// Memory-mapped I/O
</span><span>        </span><span style="color:#b48ead;">case </span><span style="color:#d08770;">0xFF10</span><span>:
</span><span>            bus-&gt;</span><span style="color:#bf616a;">set_sprite_a_register</span><span>(value);
</span><span>            </span><span style="color:#b48ead;">break</span><span>;
</span><span>
</span><span>        </span><span style="color:#b48ead;">default</span><span>:
</span><span>            </span><span style="color:#96b5b4;">printf</span><span>(&quot;</span><span style="color:#a3be8c;">Unhandled address! 0x</span><span style="color:#d08770;">%04X</span><span style="color:#96b5b4;">\n</span><span>&quot;, address);
</span><span>            </span><span style="color:#96b5b4;">exit</span><span>(</span><span style="color:#d08770;">1</span><span>);
</span><span>    }
</span><span>}
</span><span>
</span></code></pre>
<p>There's also some other considerations to have; think about how you want to plot graphics; or play audio, or read from a filesystem... there's some design choices to be made in order to properly handle the rest of the system aside from the CPU and presenting it to the user (Or letting him interact with the emulated environment!).</p>
<h1 id="bonus-track">Bonus Track</h1>
<h2 id="aot">AoT</h2>
<p>There's also a thing called Ahead-of-Time recompilation which, as you have probably already guessed; recompiles the entire target binary before running it to host-compatible machine code.</p>
<p>It's not purely emulation, but it's still a form of recompilation; it's incredibly difficult because it shares a problem that Dynamic Recompilators have; self-modifying code. If you AoT recompile a target code but it ends up self modifying, you can end up with some interesting results.</p>
<h1 id="credits">Credits</h1>
<p>With all this being said, I hope the reader finds some understanding in what emulation is about!</p>
<p>Feel free to reach out to me in case you need more resources!</p>
<p>You can also join us @ the <a href="https://discord.gg/7nuaqZ2">EmuDev</a> Discord; there's plenty of knowledgeable people that will help you in your journey!</p>
</section>

  <hr />

  <!-- Post Taxonomies -->
  
<footer class="mt-12 flex flex-col">
  <!---->
  <!---->
  <!---->
  <!---->
  
  <div class="mb-2 flex flex-wrap">
    <span class="block-bg mb-1.5 mr-1.5 rounded-lg px-5 py-1.5">Tags </span>
    
    <a
      class="block-bg block-hover mb-1.5 mr-1.5 rounded-lg px-5 py-1.5 no-underline"
      href="https://cakehonolulu.github.io/tags/emulation/"
      >emulation</a
    >
    
  </div>
  
</footer>

<!---->

  <!-- Post Nav -->
  
<nav class="block-bg mt-12 flex flex-wrap rounded-lg text-lg">
  
  <a
    class="block-hover-mask flex min-w-[50%] grow items-center rounded-l-md p-6 pr-3 font-semibold no-underline"
    href="https:&#x2F;&#x2F;cakehonolulu.github.io&#x2F;docs&#x2F;"
    ><span class="mr-1.5">←</span><span>Documentation</span></a
  >
  <!---->
  
  <a
    class="block-hover-mask ml-auto flex min-w-[50%] grow items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline"
    href="https:&#x2F;&#x2F;cakehonolulu.github.io&#x2F;hugo-to-zola-migration&#x2F;"
    ><span>Migrating my blog from Hugo to Zola</span><span class="ml-1.5">→</span></a
  >
  
</nav>

<!---->

  <!-- Comment -->
  <!---->
  <!---->
<!---->
  

  <!-- Page End inject -->
  
</article>

    </main>

    <footer class="mx-auto flex max-w-3xl flex-wrap items-center px-8 py-4 text-sm opacity-60">
  <div class="mr-auto basis-full lg:basis-1/2">
    <!---->
    <!---->
    &copy; 2022 - 2025<!---->
    
    <a class="link" href="https://cakehonolulu.github.io">
      cakehonolulu
    </a>
     |<!---->
    <!---->
    <a class="link" href="https:&#x2F;&#x2F;mit-license.org&#x2F;" rel="noopener" target="_blank">
      MIT
    </a>
    <!---->
    
  </div>
  <div class="flex basis-full lg:basis-1/2 lg:justify-end">
    <a class="link mr-6 lg:ml-6" href="https://www.getzola.org/" rel="noopener" target="_blank">
      Powered by Zola
    </a>
    <a class="link" href="https://github.com/st1020/kita" rel="noopener" target="_blank">✎ Kita</a>
  </div>
  <!-- Footer inject -->
  
</footer>


    <!-- Body End inject -->
    
  </body>
</html>
